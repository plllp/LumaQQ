// $ANTLR 3.0.1 /Users/maruojie/Projects/LumaQQ/Sources/Script/LumaQQ.g 2007-10-15 17:29:22

#import "LumaQQLexer.h"
#pragma mark Cyclic DFA implementation start LumaQQLexerDFA11
@implementation LumaQQLexerDFA11
const static int LumaQQLexerdfa11_eot[46] =
    {15,-1,-1,19,21,-1,-1,-1,-1,-1,-1,23,25,15,15,-1,15,-1,-1,-1,-1,-1,-1,
     -1,15,-1,15,31,15,15,15,-1,15,36,37,39,-1,-1,15,-1,15,15,15,15,45,-1};
const static int LumaQQLexerdfa11_eof[46] =
    {-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,
     -1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1};
const static unichar LumaQQLexerdfa11_min[46] =
    {33,0,0,61,61,0,0,0,0,0,0,48,48,105,111,0,46,0,0,0,0,0,0,0,108,0,115,
     48,110,112,116,0,110,48,48,48,0,0,99,0,116,105,111,110,48,0};
const static unichar LumaQQLexerdfa11_max[46] =
    {125,0,0,61,61,0,0,0,0,0,0,57,122,115,111,0,57,0,0,0,0,0,0,0,108,0,115,
     122,110,112,116,0,110,122,122,122,0,0,99,0,116,105,111,110,122,0};
const static int LumaQQLexerdfa11_accept[46] =
    {-1,1,2,-1,-1,7,8,9,10,11,12,-1,-1,-1,-1,20,-1,21,4,3,6,5,22,13,-1,15,
     -1,-1,-1,-1,-1,17,-1,-1,-1,-1,14,16,-1,19,-1,-1,-1,-1,-1,18};
const static int LumaQQLexerdfa11_special[46] =
    {-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,
     -1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1};
const static int LumaQQLexerdfa11_transition[] = {};
const static int LumaQQLexerdfa11_transition0[] = {15, 15, 15, 15, 15, 15, 
	15, 15, 15, 15, -1, -1, -1, -1, -1, -1, -1, 15, 15, 15, 15, 15, 15, 15, 
	15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 
	15, -1, -1, -1, -1, 15, -1, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 
	15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15};
const static int LumaQQLexerdfa11_transition1[] = {34};
const static int LumaQQLexerdfa11_transition2[] = {28};
const static int LumaQQLexerdfa11_transition3[] = {15, 15, 15, 15, 15, 15, 
	15, 15, 15, 15, -1, -1, -1, -1, -1, -1, -1, 15, 15, 15, 15, 15, 15, 15, 
	15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 
	15, -1, -1, -1, -1, 15, -1, 15, 15, 15, 15, 38, 15, 15, 15, 15, 15, 15, 
	15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15};
const static int LumaQQLexerdfa11_transition4[] = {42};
const static int LumaQQLexerdfa11_transition5[] = {20};
const static int LumaQQLexerdfa11_transition6[] = {1, 17, -1, -1, -1, -1, 
	17, -1, -1, -1, -1, 6, -1, 11, -1, 16, 16, 16, 16, 16, 16, 16, 16, 16, 
	16, -1, 5, 3, 2, 4, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 
	-1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 9, -1, 10, 
	-1, -1, -1, -1, -1, 14, -1, -1, -1, -1, 12, -1, -1, -1, 13, -1, -1, -1, 
	-1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 7, -1, 8};
const static int LumaQQLexerdfa11_transition7[] = {26, -1, -1, -1, -1, -1, 
	-1, -1, -1, -1, 27};
const static int LumaQQLexerdfa11_transition8[] = {33};
const static int LumaQQLexerdfa11_transition9[] = {40};
const static int LumaQQLexerdfa11_transition10[] = {22, -1, 16, 16, 16, 
	16, 16, 16, 16, 16, 16, 16};
const static int LumaQQLexerdfa11_transition11[] = {18};
const static int LumaQQLexerdfa11_transition12[] = {41};
const static int LumaQQLexerdfa11_transition13[] = {29};
const static int LumaQQLexerdfa11_transition14[] = {32};
const static int LumaQQLexerdfa11_transition15[] = {15, 15, 15, 15, 15, 
	15, 15, 15, 15, 15, -1, -1, -1, -1, -1, -1, -1, 15, 15, 15, 15, 15, 15, 
	15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 
	15, 15, -1, -1, -1, -1, 15, -1, 15, 15, 15, 15, 24, 15, 15, 15, 15, 15, 
	15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15};
const static int LumaQQLexerdfa11_transition16[] = {44};
const static int LumaQQLexerdfa11_transition17[] = {35};
const static int LumaQQLexerdfa11_transition18[] = {30};
const static int LumaQQLexerdfa11_transition19[] = {22, 22, 22, 22, 22, 
	22, 22, 22, 22, 22};
const static int LumaQQLexerdfa11_transition20[] = {43};


- (id) initWithRecognizer:(ANTLRBaseRecognizer *) theRecognizer
{
	if ((self = [super initWithRecognizer:theRecognizer]) != nil) {
		eot = LumaQQLexerdfa11_eot;
		eof = LumaQQLexerdfa11_eof;
		min = LumaQQLexerdfa11_min;
		max = LumaQQLexerdfa11_max;
		accept = LumaQQLexerdfa11_accept;
		special = LumaQQLexerdfa11_special;
		if (!(transition = calloc(46, sizeof(void*)))) {
			[self release];
			return nil;
		}
		transition[0] = LumaQQLexerdfa11_transition6;
		transition[1] = LumaQQLexerdfa11_transition;
		transition[2] = LumaQQLexerdfa11_transition;
		transition[3] = LumaQQLexerdfa11_transition11;
		transition[4] = LumaQQLexerdfa11_transition5;
		transition[5] = LumaQQLexerdfa11_transition;
		transition[6] = LumaQQLexerdfa11_transition;
		transition[7] = LumaQQLexerdfa11_transition;
		transition[8] = LumaQQLexerdfa11_transition;
		transition[9] = LumaQQLexerdfa11_transition;
		transition[10] = LumaQQLexerdfa11_transition;
		transition[11] = LumaQQLexerdfa11_transition19;
		transition[12] = LumaQQLexerdfa11_transition15;
		transition[13] = LumaQQLexerdfa11_transition7;
		transition[14] = LumaQQLexerdfa11_transition2;
		transition[15] = LumaQQLexerdfa11_transition;
		transition[16] = LumaQQLexerdfa11_transition10;
		transition[17] = LumaQQLexerdfa11_transition;
		transition[18] = LumaQQLexerdfa11_transition;
		transition[19] = LumaQQLexerdfa11_transition;
		transition[20] = LumaQQLexerdfa11_transition;
		transition[21] = LumaQQLexerdfa11_transition;
		transition[22] = LumaQQLexerdfa11_transition;
		transition[23] = LumaQQLexerdfa11_transition;
		transition[24] = LumaQQLexerdfa11_transition13;
		transition[25] = LumaQQLexerdfa11_transition;
		transition[26] = LumaQQLexerdfa11_transition18;
		transition[27] = LumaQQLexerdfa11_transition0;
		transition[28] = LumaQQLexerdfa11_transition14;
		transition[29] = LumaQQLexerdfa11_transition8;
		transition[30] = LumaQQLexerdfa11_transition1;
		transition[31] = LumaQQLexerdfa11_transition;
		transition[32] = LumaQQLexerdfa11_transition17;
		transition[33] = LumaQQLexerdfa11_transition0;
		transition[34] = LumaQQLexerdfa11_transition0;
		transition[35] = LumaQQLexerdfa11_transition3;
		transition[36] = LumaQQLexerdfa11_transition;
		transition[37] = LumaQQLexerdfa11_transition;
		transition[38] = LumaQQLexerdfa11_transition9;
		transition[39] = LumaQQLexerdfa11_transition;
		transition[40] = LumaQQLexerdfa11_transition12;
		transition[41] = LumaQQLexerdfa11_transition4;
		transition[42] = LumaQQLexerdfa11_transition20;
		transition[43] = LumaQQLexerdfa11_transition16;
		transition[44] = LumaQQLexerdfa11_transition0;
		transition[45] = LumaQQLexerdfa11_transition;
	}
	return self;
}

- (void) dealloc
{
	free(transition);
	[super dealloc];
}

- (NSString *) description
{
	return @"1:1: Tokens : ( NE | EQ | LT | LE | GT | GE | SEMICOLON | COMMA | OPENBRACE | CLOSEBRACE | OPENBRACKET | CLOSEBRACKET | DOT | HELP | H | LIST | LS | CONNECTION | CONN | ID | STRING | NUMBER );";
}


@end
#pragma mark Cyclic DFA implementation end LumaQQLexerDFA11



/** As per Terence: No returns for lexer rules!
#pragma mark Rule return scopes start
#pragma mark Rule return scopes end
*/
@implementation LumaQQLexer

static NSArray *tokenNames;


+ (void) initialize
{
    // todo: get tokenNames into lexer - requires changes to CodeGenerator.java and ANTLRCore.sti
    tokenNames = [[NSArray alloc] init];
}

- (id) initWithCharStream:(id<ANTLRCharStream>)anInput
{
	if (nil!=(self = [super initWithCharStream:anInput])) {
		dfa11 = [[LumaQQLexerDFA11 alloc] initWithRecognizer:self];
	}
	return self;
}

- (void) dealloc
{
	[dfa11 release];
	[super dealloc];
}

+ (NSString *) tokenNameForType:(int)aTokenType
{
    return nil;
}

+ (NSArray *) tokenNames
{
    return tokenNames;
}

- (NSString *) grammarFileName
{
	return @"/Users/maruojie/Projects/LumaQQ/Sources/Script/LumaQQ.g";
}


- (void) mNE
{
    @try {
        ruleNestingLevel++;
        int _type = LumaQQLexer_NE;
        // /Users/maruojie/Projects/LumaQQ/Sources/Script/LumaQQ.g:7:4: ( '!=' ) // ruleBlockSingleAlt
        // /Users/maruojie/Projects/LumaQQ/Sources/Script/LumaQQ.g:7:6: '!=' // alt
        {
        [self matchString:@"!="];



        }

        self->_tokenType = _type;
    }
    @finally {
        ruleNestingLevel--;
        // rule cleanup
        // token+rule list labels

    }
    return;
}
// $ANTLR end NE


- (void) mEQ
{
    @try {
        ruleNestingLevel++;
        int _type = LumaQQLexer_EQ;
        // /Users/maruojie/Projects/LumaQQ/Sources/Script/LumaQQ.g:8:4: ( '==' ) // ruleBlockSingleAlt
        // /Users/maruojie/Projects/LumaQQ/Sources/Script/LumaQQ.g:8:6: '==' // alt
        {
        [self matchString:@"=="];



        }

        self->_tokenType = _type;
    }
    @finally {
        ruleNestingLevel--;
        // rule cleanup
        // token+rule list labels

    }
    return;
}
// $ANTLR end EQ


- (void) mLT
{
    @try {
        ruleNestingLevel++;
        int _type = LumaQQLexer_LT;
        // /Users/maruojie/Projects/LumaQQ/Sources/Script/LumaQQ.g:9:4: ( '<' ) // ruleBlockSingleAlt
        // /Users/maruojie/Projects/LumaQQ/Sources/Script/LumaQQ.g:9:6: '<' // alt
        {
        [self matchChar:'<'];



        }

        self->_tokenType = _type;
    }
    @finally {
        ruleNestingLevel--;
        // rule cleanup
        // token+rule list labels

    }
    return;
}
// $ANTLR end LT


- (void) mLE
{
    @try {
        ruleNestingLevel++;
        int _type = LumaQQLexer_LE;
        // /Users/maruojie/Projects/LumaQQ/Sources/Script/LumaQQ.g:10:4: ( '<=' ) // ruleBlockSingleAlt
        // /Users/maruojie/Projects/LumaQQ/Sources/Script/LumaQQ.g:10:6: '<=' // alt
        {
        [self matchString:@"<="];



        }

        self->_tokenType = _type;
    }
    @finally {
        ruleNestingLevel--;
        // rule cleanup
        // token+rule list labels

    }
    return;
}
// $ANTLR end LE


- (void) mGT
{
    @try {
        ruleNestingLevel++;
        int _type = LumaQQLexer_GT;
        // /Users/maruojie/Projects/LumaQQ/Sources/Script/LumaQQ.g:11:4: ( '>' ) // ruleBlockSingleAlt
        // /Users/maruojie/Projects/LumaQQ/Sources/Script/LumaQQ.g:11:6: '>' // alt
        {
        [self matchChar:'>'];



        }

        self->_tokenType = _type;
    }
    @finally {
        ruleNestingLevel--;
        // rule cleanup
        // token+rule list labels

    }
    return;
}
// $ANTLR end GT


- (void) mGE
{
    @try {
        ruleNestingLevel++;
        int _type = LumaQQLexer_GE;
        // /Users/maruojie/Projects/LumaQQ/Sources/Script/LumaQQ.g:12:4: ( '>=' ) // ruleBlockSingleAlt
        // /Users/maruojie/Projects/LumaQQ/Sources/Script/LumaQQ.g:12:6: '>=' // alt
        {
        [self matchString:@">="];



        }

        self->_tokenType = _type;
    }
    @finally {
        ruleNestingLevel--;
        // rule cleanup
        // token+rule list labels

    }
    return;
}
// $ANTLR end GE


- (void) mSEMICOLON
{
    @try {
        ruleNestingLevel++;
        int _type = LumaQQLexer_SEMICOLON;
        // /Users/maruojie/Projects/LumaQQ/Sources/Script/LumaQQ.g:13:11: ( ';' ) // ruleBlockSingleAlt
        // /Users/maruojie/Projects/LumaQQ/Sources/Script/LumaQQ.g:13:13: ';' // alt
        {
        [self matchChar:';'];



        }

        self->_tokenType = _type;
    }
    @finally {
        ruleNestingLevel--;
        // rule cleanup
        // token+rule list labels

    }
    return;
}
// $ANTLR end SEMICOLON


- (void) mCOMMA
{
    @try {
        ruleNestingLevel++;
        int _type = LumaQQLexer_COMMA;
        // /Users/maruojie/Projects/LumaQQ/Sources/Script/LumaQQ.g:14:7: ( ',' ) // ruleBlockSingleAlt
        // /Users/maruojie/Projects/LumaQQ/Sources/Script/LumaQQ.g:14:9: ',' // alt
        {
        [self matchChar:','];



        }

        self->_tokenType = _type;
    }
    @finally {
        ruleNestingLevel--;
        // rule cleanup
        // token+rule list labels

    }
    return;
}
// $ANTLR end COMMA


- (void) mOPENBRACE
{
    @try {
        ruleNestingLevel++;
        int _type = LumaQQLexer_OPENBRACE;
        // /Users/maruojie/Projects/LumaQQ/Sources/Script/LumaQQ.g:15:11: ( '{' ) // ruleBlockSingleAlt
        // /Users/maruojie/Projects/LumaQQ/Sources/Script/LumaQQ.g:15:13: '{' // alt
        {
        [self matchChar:'{'];



        }

        self->_tokenType = _type;
    }
    @finally {
        ruleNestingLevel--;
        // rule cleanup
        // token+rule list labels

    }
    return;
}
// $ANTLR end OPENBRACE


- (void) mCLOSEBRACE
{
    @try {
        ruleNestingLevel++;
        int _type = LumaQQLexer_CLOSEBRACE;
        // /Users/maruojie/Projects/LumaQQ/Sources/Script/LumaQQ.g:16:12: ( '}' ) // ruleBlockSingleAlt
        // /Users/maruojie/Projects/LumaQQ/Sources/Script/LumaQQ.g:16:14: '}' // alt
        {
        [self matchChar:'}'];



        }

        self->_tokenType = _type;
    }
    @finally {
        ruleNestingLevel--;
        // rule cleanup
        // token+rule list labels

    }
    return;
}
// $ANTLR end CLOSEBRACE


- (void) mOPENBRACKET
{
    @try {
        ruleNestingLevel++;
        int _type = LumaQQLexer_OPENBRACKET;
        // /Users/maruojie/Projects/LumaQQ/Sources/Script/LumaQQ.g:17:13: ( '[' ) // ruleBlockSingleAlt
        // /Users/maruojie/Projects/LumaQQ/Sources/Script/LumaQQ.g:17:15: '[' // alt
        {
        [self matchChar:'['];



        }

        self->_tokenType = _type;
    }
    @finally {
        ruleNestingLevel--;
        // rule cleanup
        // token+rule list labels

    }
    return;
}
// $ANTLR end OPENBRACKET


- (void) mCLOSEBRACKET
{
    @try {
        ruleNestingLevel++;
        int _type = LumaQQLexer_CLOSEBRACKET;
        // /Users/maruojie/Projects/LumaQQ/Sources/Script/LumaQQ.g:18:14: ( ']' ) // ruleBlockSingleAlt
        // /Users/maruojie/Projects/LumaQQ/Sources/Script/LumaQQ.g:18:16: ']' // alt
        {
        [self matchChar:']'];



        }

        self->_tokenType = _type;
    }
    @finally {
        ruleNestingLevel--;
        // rule cleanup
        // token+rule list labels

    }
    return;
}
// $ANTLR end CLOSEBRACKET


- (void) mDOT
{
    @try {
        ruleNestingLevel++;
        int _type = LumaQQLexer_DOT;
        // /Users/maruojie/Projects/LumaQQ/Sources/Script/LumaQQ.g:19:5: ( '.' ) // ruleBlockSingleAlt
        // /Users/maruojie/Projects/LumaQQ/Sources/Script/LumaQQ.g:19:7: '.' // alt
        {
        [self matchChar:'.'];



        }

        self->_tokenType = _type;
    }
    @finally {
        ruleNestingLevel--;
        // rule cleanup
        // token+rule list labels

    }
    return;
}
// $ANTLR end DOT


- (void) mHELP
{
    @try {
        ruleNestingLevel++;
        int _type = LumaQQLexer_HELP;
        // /Users/maruojie/Projects/LumaQQ/Sources/Script/LumaQQ.g:20:6: ( 'help' ) // ruleBlockSingleAlt
        // /Users/maruojie/Projects/LumaQQ/Sources/Script/LumaQQ.g:20:8: 'help' // alt
        {
        [self matchString:@"help"];



        }

        self->_tokenType = _type;
    }
    @finally {
        ruleNestingLevel--;
        // rule cleanup
        // token+rule list labels

    }
    return;
}
// $ANTLR end HELP


- (void) mH
{
    @try {
        ruleNestingLevel++;
        int _type = LumaQQLexer_H;
        // /Users/maruojie/Projects/LumaQQ/Sources/Script/LumaQQ.g:21:3: ( 'h' ) // ruleBlockSingleAlt
        // /Users/maruojie/Projects/LumaQQ/Sources/Script/LumaQQ.g:21:5: 'h' // alt
        {
        [self matchChar:'h'];



        }

        self->_tokenType = _type;
    }
    @finally {
        ruleNestingLevel--;
        // rule cleanup
        // token+rule list labels

    }
    return;
}
// $ANTLR end H


- (void) mLIST
{
    @try {
        ruleNestingLevel++;
        int _type = LumaQQLexer_LIST;
        // /Users/maruojie/Projects/LumaQQ/Sources/Script/LumaQQ.g:22:6: ( 'list' ) // ruleBlockSingleAlt
        // /Users/maruojie/Projects/LumaQQ/Sources/Script/LumaQQ.g:22:8: 'list' // alt
        {
        [self matchString:@"list"];



        }

        self->_tokenType = _type;
    }
    @finally {
        ruleNestingLevel--;
        // rule cleanup
        // token+rule list labels

    }
    return;
}
// $ANTLR end LIST


- (void) mLS
{
    @try {
        ruleNestingLevel++;
        int _type = LumaQQLexer_LS;
        // /Users/maruojie/Projects/LumaQQ/Sources/Script/LumaQQ.g:23:4: ( 'ls' ) // ruleBlockSingleAlt
        // /Users/maruojie/Projects/LumaQQ/Sources/Script/LumaQQ.g:23:6: 'ls' // alt
        {
        [self matchString:@"ls"];



        }

        self->_tokenType = _type;
    }
    @finally {
        ruleNestingLevel--;
        // rule cleanup
        // token+rule list labels

    }
    return;
}
// $ANTLR end LS


- (void) mCONNECTION
{
    @try {
        ruleNestingLevel++;
        int _type = LumaQQLexer_CONNECTION;
        // /Users/maruojie/Projects/LumaQQ/Sources/Script/LumaQQ.g:24:12: ( 'connection' ) // ruleBlockSingleAlt
        // /Users/maruojie/Projects/LumaQQ/Sources/Script/LumaQQ.g:24:14: 'connection' // alt
        {
        [self matchString:@"connection"];



        }

        self->_tokenType = _type;
    }
    @finally {
        ruleNestingLevel--;
        // rule cleanup
        // token+rule list labels

    }
    return;
}
// $ANTLR end CONNECTION


- (void) mCONN
{
    @try {
        ruleNestingLevel++;
        int _type = LumaQQLexer_CONN;
        // /Users/maruojie/Projects/LumaQQ/Sources/Script/LumaQQ.g:25:6: ( 'conn' ) // ruleBlockSingleAlt
        // /Users/maruojie/Projects/LumaQQ/Sources/Script/LumaQQ.g:25:8: 'conn' // alt
        {
        [self matchString:@"conn"];



        }

        self->_tokenType = _type;
    }
    @finally {
        ruleNestingLevel--;
        // rule cleanup
        // token+rule list labels

    }
    return;
}
// $ANTLR end CONN


- (void) mDIGIT
{
    @try {
        ruleNestingLevel++;
        // /Users/maruojie/Projects/LumaQQ/Sources/Script/LumaQQ.g:38:7: ( '0' .. '9' ) // ruleBlockSingleAlt
        // /Users/maruojie/Projects/LumaQQ/Sources/Script/LumaQQ.g:38:9: '0' .. '9' // alt
        {
        [self matchRangeFromChar:'0' to:'9'];

        }

    }
    @finally {
        ruleNestingLevel--;
        // rule cleanup
        // token+rule list labels

    }
    return;
}
// $ANTLR end DIGIT


- (void) mID
{
    @try {
        ruleNestingLevel++;
        int _type = LumaQQLexer_ID;
        // /Users/maruojie/Projects/LumaQQ/Sources/Script/LumaQQ.g:40:4: ( ( 'a' .. 'z' | 'A' .. 'Z' | '_' )? ( 'a' .. 'z' | 'A' .. 'Z' | '_' | '0' .. '9' )* ) // ruleBlockSingleAlt
        // /Users/maruojie/Projects/LumaQQ/Sources/Script/LumaQQ.g:40:6: ( 'a' .. 'z' | 'A' .. 'Z' | '_' )? ( 'a' .. 'z' | 'A' .. 'Z' | '_' | '0' .. '9' )* // alt
        {
        // /Users/maruojie/Projects/LumaQQ/Sources/Script/LumaQQ.g:40:6: ( 'a' .. 'z' | 'A' .. 'Z' | '_' )? // block
        int alt1=2;
        {
        	int LA1_0 = [input LA:1];
        	if ( (LA1_0>='A' && LA1_0<='Z')||LA1_0=='_'||(LA1_0>='a' && LA1_0<='z') ) {
        		alt1 = 1;
        	}
        }
        switch (alt1) {
        	case 1 :
        	    // /Users/maruojie/Projects/LumaQQ/Sources/Script/LumaQQ.g: // alt
        	    {
        	    if (([input LA:1]>='A' && [input LA:1]<='Z')||[input LA:1]=='_'||([input LA:1]>='a' && [input LA:1]<='z')) {
        	    	[input consume];

        	    } else {
        	    	ANTLRMismatchedSetException *mse = [ANTLRMismatchedSetException exceptionWithSet:nil stream:input];
        	    	[self recover:mse];	@throw mse;
        	    }


        	    }
        	    break;

        }

        do {
            int alt2=2;
            {
            	int LA2_0 = [input LA:1];
            	if ( (LA2_0>='0' && LA2_0<='9')||(LA2_0>='A' && LA2_0<='Z')||LA2_0=='_'||(LA2_0>='a' && LA2_0<='z') ) {
            		alt2 = 1;
            	}

            }
            switch (alt2) {
        	case 1 :
        	    // /Users/maruojie/Projects/LumaQQ/Sources/Script/LumaQQ.g: // alt
        	    {
        	    if (([input LA:1]>='0' && [input LA:1]<='9')||([input LA:1]>='A' && [input LA:1]<='Z')||[input LA:1]=='_'||([input LA:1]>='a' && [input LA:1]<='z')) {
        	    	[input consume];

        	    } else {
        	    	ANTLRMismatchedSetException *mse = [ANTLRMismatchedSetException exceptionWithSet:nil stream:input];
        	    	[self recover:mse];	@throw mse;
        	    }


        	    }
        	    break;

        	default :
        	    goto loop2;
            }
        } while (YES); loop2: ;


        }

        self->_tokenType = _type;
    }
    @finally {
        ruleNestingLevel--;
        // rule cleanup
        // token+rule list labels

    }
    return;
}
// $ANTLR end ID


- (void) mSTRING
{
    @try {
        ruleNestingLevel++;
        int _type = LumaQQLexer_STRING;
        // /Users/maruojie/Projects/LumaQQ/Sources/Script/LumaQQ.g:41:8: ( '\\'' ( options {greedy=false; } : ~ '\\'' )* '\\'' | '\"' ( options {greedy=false; } : ~ '\"' )* '\"' ) //ruleblock
        int alt5=2;
        {
        	int LA5_0 = [input LA:1];
        	if ( LA5_0=='\'' ) {
        		alt5 = 1;
        	}
        	else if ( LA5_0=='"' ) {
        		alt5 = 2;
        	}
        else {
            ANTLRNoViableAltException *nvae = [ANTLRNoViableAltException exceptionWithDecision:5 state:0 stream:input];
        	@throw nvae;
        	}
        }
        switch (alt5) {
        	case 1 :
        	    // /Users/maruojie/Projects/LumaQQ/Sources/Script/LumaQQ.g:41:10: '\\'' ( options {greedy=false; } : ~ '\\'' )* '\\'' // alt
        	    {
        	    [self matchChar:'\''];


        	    do {
        	        int alt3=2;
        	        {
        	        	int LA3_0 = [input LA:1];
        	        	if ( LA3_0=='\'' ) {
        	        		alt3 = 2;
        	        	}
        	        	else if ( (LA3_0>=0x0000 && LA3_0<='&')||(LA3_0>='(' && LA3_0<=0xFFFE) ) {
        	        		alt3 = 1;
        	        	}

        	        }
        	        switch (alt3) {
        	    	case 1 :
        	    	    // /Users/maruojie/Projects/LumaQQ/Sources/Script/LumaQQ.g:41:46: ~ '\\'' // alt
        	    	    {
        	    	    if (([input LA:1]>=0x0000 && [input LA:1]<='&')||([input LA:1]>='(' && [input LA:1]<=0xFFFE)) {
        	    	    	[input consume];

        	    	    } else {
        	    	    	ANTLRMismatchedSetException *mse = [ANTLRMismatchedSetException exceptionWithSet:nil stream:input];
        	    	    	[self recover:mse];	@throw mse;
        	    	    }


        	    	    }
        	    	    break;

        	    	default :
        	    	    goto loop3;
        	        }
        	    } while (YES); loop3: ;

        	    [self matchChar:'\''];



        	    }
        	    break;
        	case 2 :
        	    // /Users/maruojie/Projects/LumaQQ/Sources/Script/LumaQQ.g:42:4: '\"' ( options {greedy=false; } : ~ '\"' )* '\"' // alt
        	    {
        	    [self matchChar:'"'];


        	    do {
        	        int alt4=2;
        	        {
        	        	int LA4_0 = [input LA:1];
        	        	if ( LA4_0=='"' ) {
        	        		alt4 = 2;
        	        	}
        	        	else if ( (LA4_0>=0x0000 && LA4_0<='!')||(LA4_0>='#' && LA4_0<=0xFFFE) ) {
        	        		alt4 = 1;
        	        	}

        	        }
        	        switch (alt4) {
        	    	case 1 :
        	    	    // /Users/maruojie/Projects/LumaQQ/Sources/Script/LumaQQ.g:42:39: ~ '\"' // alt
        	    	    {
        	    	    if (([input LA:1]>=0x0000 && [input LA:1]<='!')||([input LA:1]>='#' && [input LA:1]<=0xFFFE)) {
        	    	    	[input consume];

        	    	    } else {
        	    	    	ANTLRMismatchedSetException *mse = [ANTLRMismatchedSetException exceptionWithSet:nil stream:input];
        	    	    	[self recover:mse];	@throw mse;
        	    	    }


        	    	    }
        	    	    break;

        	    	default :
        	    	    goto loop4;
        	        }
        	    } while (YES); loop4: ;

        	    [self matchChar:'"'];



        	    }
        	    break;

        }
        self->_tokenType = _type;
    }
    @finally {
        ruleNestingLevel--;
        // rule cleanup
        // token+rule list labels

    }
    return;
}
// $ANTLR end STRING


- (void) mNUMBER
{
    @try {
        ruleNestingLevel++;
        int _type = LumaQQLexer_NUMBER;
        // /Users/maruojie/Projects/LumaQQ/Sources/Script/LumaQQ.g:44:8: ( ( DIGIT )+ ( '.' ( DIGIT )? )? | '.' ( DIGIT )+ ) //ruleblock
        int alt10=2;
        {
        	int LA10_0 = [input LA:1];
        	if ( (LA10_0>='0' && LA10_0<='9') ) {
        		alt10 = 1;
        	}
        	else if ( LA10_0=='.' ) {
        		alt10 = 2;
        	}
        else {
            ANTLRNoViableAltException *nvae = [ANTLRNoViableAltException exceptionWithDecision:10 state:0 stream:input];
        	@throw nvae;
        	}
        }
        switch (alt10) {
        	case 1 :
        	    // /Users/maruojie/Projects/LumaQQ/Sources/Script/LumaQQ.g:44:10: ( DIGIT )+ ( '.' ( DIGIT )? )? // alt
        	    {
        	    // /Users/maruojie/Projects/LumaQQ/Sources/Script/LumaQQ.g:44:10: ( DIGIT )+	// positiveClosureBlock
        	    int cnt6=0;

        	    do {
        	        int alt6=2;
        	        {
        	        	int LA6_0 = [input LA:1];
        	        	if ( (LA6_0>='0' && LA6_0<='9') ) {
        	        		alt6 = 1;
        	        	}

        	        }
        	        switch (alt6) {
        	    	case 1 :
        	    	    // /Users/maruojie/Projects/LumaQQ/Sources/Script/LumaQQ.g:44:10: DIGIT // alt
        	    	    {
        	    	    [self mDIGIT];



        	    	    }
        	    	    break;

        	    	default :
        	    	    if ( cnt6 >= 1 )  goto loop6;
        	    			ANTLREarlyExitException *eee = [ANTLREarlyExitException exceptionWithStream:input decisionNumber:6];
        	    			@throw eee;
        	        }
        	        cnt6++;
        	    } while (YES); loop6: ;

        	    // /Users/maruojie/Projects/LumaQQ/Sources/Script/LumaQQ.g:44:17: ( '.' ( DIGIT )? )? // block
        	    int alt8=2;
        	    {
        	    	int LA8_0 = [input LA:1];
        	    	if ( LA8_0=='.' ) {
        	    		alt8 = 1;
        	    	}
        	    }
        	    switch (alt8) {
        	    	case 1 :
        	    	    // /Users/maruojie/Projects/LumaQQ/Sources/Script/LumaQQ.g:44:18: '.' ( DIGIT )? // alt
        	    	    {
        	    	    [self matchChar:'.'];


        	    	    // /Users/maruojie/Projects/LumaQQ/Sources/Script/LumaQQ.g:44:22: ( DIGIT )? // block
        	    	    int alt7=2;
        	    	    {
        	    	    	int LA7_0 = [input LA:1];
        	    	    	if ( (LA7_0>='0' && LA7_0<='9') ) {
        	    	    		alt7 = 1;
        	    	    	}
        	    	    }
        	    	    switch (alt7) {
        	    	    	case 1 :
        	    	    	    // /Users/maruojie/Projects/LumaQQ/Sources/Script/LumaQQ.g:44:22: DIGIT // alt
        	    	    	    {
        	    	    	    [self mDIGIT];



        	    	    	    }
        	    	    	    break;

        	    	    }


        	    	    }
        	    	    break;

        	    }


        	    }
        	    break;
        	case 2 :
        	    // /Users/maruojie/Projects/LumaQQ/Sources/Script/LumaQQ.g:45:4: '.' ( DIGIT )+ // alt
        	    {
        	    [self matchChar:'.'];


        	    // /Users/maruojie/Projects/LumaQQ/Sources/Script/LumaQQ.g:45:8: ( DIGIT )+	// positiveClosureBlock
        	    int cnt9=0;

        	    do {
        	        int alt9=2;
        	        {
        	        	int LA9_0 = [input LA:1];
        	        	if ( (LA9_0>='0' && LA9_0<='9') ) {
        	        		alt9 = 1;
        	        	}

        	        }
        	        switch (alt9) {
        	    	case 1 :
        	    	    // /Users/maruojie/Projects/LumaQQ/Sources/Script/LumaQQ.g:45:8: DIGIT // alt
        	    	    {
        	    	    [self mDIGIT];



        	    	    }
        	    	    break;

        	    	default :
        	    	    if ( cnt9 >= 1 )  goto loop9;
        	    			ANTLREarlyExitException *eee = [ANTLREarlyExitException exceptionWithStream:input decisionNumber:9];
        	    			@throw eee;
        	        }
        	        cnt9++;
        	    } while (YES); loop9: ;


        	    }
        	    break;

        }
        self->_tokenType = _type;
    }
    @finally {
        ruleNestingLevel--;
        // rule cleanup
        // token+rule list labels

    }
    return;
}
// $ANTLR end NUMBER

- (void) mTokens
{
    // /Users/maruojie/Projects/LumaQQ/Sources/Script/LumaQQ.g:1:8: ( NE | EQ | LT | LE | GT | GE | SEMICOLON | COMMA | OPENBRACE | CLOSEBRACE | OPENBRACKET | CLOSEBRACKET | DOT | HELP | H | LIST | LS | CONNECTION | CONN | ID | STRING | NUMBER ) //ruleblock
    int alt11=22;
    alt11 = [dfa11 predict];
    switch (alt11) {
    	case 1 :
    	    // /Users/maruojie/Projects/LumaQQ/Sources/Script/LumaQQ.g:1:10: NE // alt
    	    {
    	    [self mNE];



    	    }
    	    break;
    	case 2 :
    	    // /Users/maruojie/Projects/LumaQQ/Sources/Script/LumaQQ.g:1:13: EQ // alt
    	    {
    	    [self mEQ];



    	    }
    	    break;
    	case 3 :
    	    // /Users/maruojie/Projects/LumaQQ/Sources/Script/LumaQQ.g:1:16: LT // alt
    	    {
    	    [self mLT];



    	    }
    	    break;
    	case 4 :
    	    // /Users/maruojie/Projects/LumaQQ/Sources/Script/LumaQQ.g:1:19: LE // alt
    	    {
    	    [self mLE];



    	    }
    	    break;
    	case 5 :
    	    // /Users/maruojie/Projects/LumaQQ/Sources/Script/LumaQQ.g:1:22: GT // alt
    	    {
    	    [self mGT];



    	    }
    	    break;
    	case 6 :
    	    // /Users/maruojie/Projects/LumaQQ/Sources/Script/LumaQQ.g:1:25: GE // alt
    	    {
    	    [self mGE];



    	    }
    	    break;
    	case 7 :
    	    // /Users/maruojie/Projects/LumaQQ/Sources/Script/LumaQQ.g:1:28: SEMICOLON // alt
    	    {
    	    [self mSEMICOLON];



    	    }
    	    break;
    	case 8 :
    	    // /Users/maruojie/Projects/LumaQQ/Sources/Script/LumaQQ.g:1:38: COMMA // alt
    	    {
    	    [self mCOMMA];



    	    }
    	    break;
    	case 9 :
    	    // /Users/maruojie/Projects/LumaQQ/Sources/Script/LumaQQ.g:1:44: OPENBRACE // alt
    	    {
    	    [self mOPENBRACE];



    	    }
    	    break;
    	case 10 :
    	    // /Users/maruojie/Projects/LumaQQ/Sources/Script/LumaQQ.g:1:54: CLOSEBRACE // alt
    	    {
    	    [self mCLOSEBRACE];



    	    }
    	    break;
    	case 11 :
    	    // /Users/maruojie/Projects/LumaQQ/Sources/Script/LumaQQ.g:1:65: OPENBRACKET // alt
    	    {
    	    [self mOPENBRACKET];



    	    }
    	    break;
    	case 12 :
    	    // /Users/maruojie/Projects/LumaQQ/Sources/Script/LumaQQ.g:1:77: CLOSEBRACKET // alt
    	    {
    	    [self mCLOSEBRACKET];



    	    }
    	    break;
    	case 13 :
    	    // /Users/maruojie/Projects/LumaQQ/Sources/Script/LumaQQ.g:1:90: DOT // alt
    	    {
    	    [self mDOT];



    	    }
    	    break;
    	case 14 :
    	    // /Users/maruojie/Projects/LumaQQ/Sources/Script/LumaQQ.g:1:94: HELP // alt
    	    {
    	    [self mHELP];



    	    }
    	    break;
    	case 15 :
    	    // /Users/maruojie/Projects/LumaQQ/Sources/Script/LumaQQ.g:1:99: H // alt
    	    {
    	    [self mH];



    	    }
    	    break;
    	case 16 :
    	    // /Users/maruojie/Projects/LumaQQ/Sources/Script/LumaQQ.g:1:101: LIST // alt
    	    {
    	    [self mLIST];



    	    }
    	    break;
    	case 17 :
    	    // /Users/maruojie/Projects/LumaQQ/Sources/Script/LumaQQ.g:1:106: LS // alt
    	    {
    	    [self mLS];



    	    }
    	    break;
    	case 18 :
    	    // /Users/maruojie/Projects/LumaQQ/Sources/Script/LumaQQ.g:1:109: CONNECTION // alt
    	    {
    	    [self mCONNECTION];



    	    }
    	    break;
    	case 19 :
    	    // /Users/maruojie/Projects/LumaQQ/Sources/Script/LumaQQ.g:1:120: CONN // alt
    	    {
    	    [self mCONN];



    	    }
    	    break;
    	case 20 :
    	    // /Users/maruojie/Projects/LumaQQ/Sources/Script/LumaQQ.g:1:125: ID // alt
    	    {
    	    [self mID];



    	    }
    	    break;
    	case 21 :
    	    // /Users/maruojie/Projects/LumaQQ/Sources/Script/LumaQQ.g:1:128: STRING // alt
    	    {
    	    [self mSTRING];



    	    }
    	    break;
    	case 22 :
    	    // /Users/maruojie/Projects/LumaQQ/Sources/Script/LumaQQ.g:1:135: NUMBER // alt
    	    {
    	    [self mNUMBER];



    	    }
    	    break;

    }

}

@end